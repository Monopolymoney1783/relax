#!/usr/bin/env bash -eu
# @(#) relax: `export` command
# completions

usage_export () {
	cat <<-EOM
	usage: ${ME} export <release> [<archive-path>]

	If you don't specify an archive, it will export the last one of
	a release type.
	EOM
}

export_generate_optoin_list() {
	logi "$ARROW Generating ExportOptions.plist"

	local plistbuddy_cmd_file=$REL_TEMP_DIR/plistbuddy_cmd
	cp "${SOURCE_PATH}"/etc/empty.plist $EXPORT_OPTIONS_PLIST

	if [ ! -z $export_option_method ]; then
		echo "Add :method string $export_option_method" \
			>> $plistbuddy_cmd_file
	else 
		die "Undefined a method of ExportOptions plist in Relfile"
	fi

	if [ ! -z $team_id ]; then
		echo "Add :teamID string $team_id" \
			>> $plistbuddy_cmd_file
	fi

	if [ ! -z $export_option_thinning ]; then
		echo "Add :thinning string '$export_option_thinning'" \
			>> $plistbuddy_cmd_file
	fi

	if [ ! -z $export_option_compile_bitcode ]; then
		echo "Add :compileBitcode bool $export_option_compile_bitcode" \
			>> $plistbuddy_cmd_file
	fi

	local is_appstore=false
	if [ $export_option_method = "appstore" ]; then
		is_appstore=true
	fi

	# For App Store
	if [ ! -z $export_option_upload_symbols ]; then
		if ! $is_appstore; then
			logi "$WARN uploadSymbol options is for App Store exports."
		fi
		echo "Add :updateSymbols bool $export_option_upload_symbols" \
			>> $plistbuddy_cmd_file
	fi

	# For App Store
	if [ ! -z $export_option_upload_bitcode ]; then
		if ! $is_appstore; then
			logi "$WARN uploadBitcode options is for App Store exports."
		fi
		echo "Add :uploadBitcode bool $export_option_upload_bitcode" \
			>> $plistbuddy_cmd_file
	fi

	cat $plistbuddy_cmd_file | \
		xargs -I{} /usr/libexec/PlistBuddy -c {} $EXPORT_OPTIONS_PLIST

	cat $EXPORT_OPTIONS_PLIST
}

export_archive () {
	if [[ $# != 1 ]]; then
		die "export_archive: bad argument"
	fi

	logi "$ARROW Exporting $1"

	local export_path="${1%/*}"
	local export_option_plist=$EXPORT_OPTIONS_PLIST

	local archive_path="$REL_TEMP_DIR/xcarchive"
	cp -a "$1" "$archive_path"

	export_generate_optoin_list
	
	local app_path="$(find "$archive_path" -name *.app)";
	if cat "${app_path}/$ARCHIVED_ENTITLEMENTS_XCENT" | grep -q "$team_id"; then
		:
	else
		for pt in ${REL_RELEASES[@]}; do
			if echo "$export_path" | grep -q $pt; then
				export_path=$(echo "$export_path" | \
					sed "s:\(.*\)$pt\(.*\):\1$release\2:")
				break
			fi
		done
		logi "$ARROW Update $ARCHIVED_ENTITLEMENTS_XCENT. IPA file will be exported in $export_path"
		update_archived_entitlements_xcent "$team_id" "$app_path"
	fi

	if [ -z "$(find "$archive_path" -type f)" ]; then
		die "Failed to acrhive: $archive_path is empty"
	fi

	if test -d "$archive_path/dSYMs"; then
		logi "$ARROW Fetching dSYMs"
	
		local dsym_file="$export_path/$PRODUCT_NAME.dSYMs.zip"
		ditto -c -k --sequesterRsrc --keepParent "$archive_path/dSYMs" "$dsym_file"

		logi "dSYMs.zip: $dsym_file"
	fi

	logi "$ARROW Creating IPA"

	if [ -f "$export_path/$PRODUCT_NAME.ipa" ]; then 
		logi "Found the same IPA file so it is removed."
		rm -rf "$export_path/$PRODUCT_NAME.ipa"
	fi

	local params=()
	params+=(-exportArchive -archivePath "$archive_path" -exportPath "$export_path")
	params+=(-exportOptionsPlist "$export_option_plist")

	### Deprecated
	#params=(-exportFormat ipa)
	#params+=(-exportProvisioningProfile "$provisioning_name")

	logfile="$export_path/export.log"
	logi "Run: xcodebuild ${params[@]}"
	logi "Log: ${logfile}"

	rm -rf "${logfile}"
	if [[ "${REL_LOG_LEVEL:-undefined}" =~ .*"$REL_LOG_LEVEL_VERBOSE".* ]]; then
		xcodebuild "${params[@]}" > >(tee -a "${logfile}") 2> >(tee -a "${logfile}" >&2)  || return 1
	else
		xcodebuild "${params[@]}" > >(tee -a "${logfile}" >/dev/null) 2> >(tee -a "${logfile}" >&2) &
		XCODEBUILD_PID=$!
		if ! print_progress_time $XCODEBUILD_PID; then
			return 1
		fi
	fi

	# update a symbolic link of the latest archive
	find "$export_path" -name "*.ipa"
	if [[ ! -n $(find "$export_path" -name "*.ipa") ]]; then
		die "Not found IPA file in $export_path"
	fi

	local ipa_path=$(find "$export_path" -maxdepth 1 -mindepth 1 -name "*.ipa" | head -1)
	logi "IPA: $ipa_path"

	rm -f "$LATEST_IPA"
	ln -fs "$ipa_path" "$LATEST_IPA"
	rm -f "$LATEST_EXPORT_DIR"
	ln -fs "$export_path" "$LATEST_EXPORT_DIR"
}

prepare_export() {
	local data_root="$REL_RELEASE_ROOT/$release/$REL_DATA_DIR"
	mkdir -p "$data_root"
	LATEST_IPA="$data_root/LATEST_IPA"
	LATEST_EXPORT_DIR="$data_root/LATEST_EXPORT_DIR"
	EXPORT_OPTIONS_PLIST=$REL_TEMP_DIR/ExportOptions.plist
}

if [ $# = 0 ]
then
	usage_export
	fin
fi

target_archive_file=""
release=

while [ $# -ne 0 ];
do
	arg=$1
	shift
	case $arg in
	-h|--help)
		usage_export
		fin
		;;
	--complete)
		fin
		;;
	*)
		if [[ $arg =~ (.).xcarchive ]]; then
			target_archive_file="$arg"
			if [[ ! -d $target_archive_file ]]; then
				die "Not found $target_archive_file "
			fi
		else
			release=$arg
		fi
		;;
	esac
done

if test ${release:-undefined} = undefined; then
	usage_export
	fin
fi

if [[ -z "$target_archive_file" ]]; then
	target_archive_file="$(relax-show $release archive)"
	if [[ ! -d $target_archive_file ]]; then
		die "Not found the last archive. Please archive '$release'"
	fi
fi


trap 'teardown_build' EXIT INT TERM
setup_build $release
prepare_export

export_archive "$target_archive_file"
